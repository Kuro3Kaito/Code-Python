# Django
## Cơ chế và thuật ngữ ứng dụng web
1. URL/URI:	Bộ định vị tài nguyên thống nhất/Mã định danh tài nguyên đồng nhất, nhận dạng duy nhất các tài nguyên mạng
2. tên miền: Tên chuỗi dễ nhớ tương ứng với địa chỉ máy chủ web
3. DNS:	Dịch vụ phân giải tên miền có thể chuyển đổi tên miền thành địa chỉ IP tương ứng
4. địa chỉ IP: Danh tính của một máy chủ trên mạng. Các máy chủ khác nhau có thể được phân biệt thông qua địa chỉ IP.
5. HTTP: Giao thức truyền siêu văn bản, giao thức cấp ứng dụng được xây dựng dựa trên TCP, nền tảng của truyền thông dữ liệu World Wide Web
6. proxy ngược:	Máy khách proxy gửi yêu cầu đến máy chủ và sau đó trả lại tài nguyên được máy chủ trả về cho máy khách
7. máy chủ web:	Chấp nhận các yêu cầu HTTP và trả lại tệp HTML, tệp văn bản thuần túy, hình ảnh và các tài nguyên khác cho người yêu cầu
8. Nginx: Máy chủ web hiệu suất cao cũng có thể được sử dụng làm proxy ngược , cân bằng tải  và  bộ đệm HTTP

### Giao thức HTTP
HTTP (Giao thức truyền siêu văn bản) là giao thức cấp ứng dụng được xây dựng trên TCP (Giao thức điều khiển truyền), sử dụng dịch vụ truyền đáng tin cậy do TCP cung cấp để thực hiện trao đổi dữ liệu trong các ứng dụng Web
Yêu cầu HTTP (dòng yêu cầu + tiêu đề yêu cầu + dòng trống + [nội dung thư]):
Phản hồi HTTP (dòng phản hồi + tiêu đề phản hồi + dòng trống + nội dung thư):

## Tạo dự án và ứng dụng
bắt đầu bằng cách tạo một dự án Django votevà thêm môi trường ảo cũng như các phần phụ thuộc vào polls đó. Tiếp theo, tạo thư mục có tên Ứng dụng và lưu trang mẫu trong dự án.Cấu trúc tempaltes của thư mục dự án

## Cấu hình cơ sở dữ liệu quan hệ MySQL
1. Tạo cơ sở dữ liệu trong MySQL, tạo người dùng và ủy quyền cho người dùng truy cập cơ sở dữ liệu.
    create database vote default charset utf8;
    create user 'hellokitty'@'%' identified by 'Hellokitty.618';
    grant all privileges on vote.* to 'hellokitty'@'%';
    flush privileges;
2. Tạo bảng hai chiều trong MySQL lưu trữ thông tin môn học và giáo viên
3. Cài đặt các phần phụ thuộc cần thiết để kết nối với cơ sở dữ liệu MySQL trong môi trường ảo.
4. Sửa đổi tệp settings.py của dự án, trước tiên hãy thêm ứng dụng chúng tôi đã tạo pollsvào dự án đã cài đặt ( INSTALLED_APPS), sau đó định cấu hình MySQL làm giải pháp lưu trữ lâu dài.
Khi định cấu hình thuộc tính ENGINE, các giá trị tùy chọn thường được sử dụng bao gồm:
    'django.db.backends.sqlite3':Cơ sở dữ liệu nhúng SQLite.
    'django.db.backends.postgresql': Một sản phẩm cơ sở dữ liệu quan hệ nguồn mở được phát hành theo giấy phép BSD.
    'django.db.backends.mysql': Sản phẩm cơ sở dữ liệu hiệu quả về mặt chi phí của Oracle.
    'django.db.backends.oracle': Sản phẩm cơ sở dữ liệu quan hệ hàng đầu của Oracle.
5. Mục đích của việc sử dụng ORM là thực hiện chuyển đổi hai chiều từ mô hình đối tượng sang mô hình quan hệ , do đó không cần phải viết câu lệnh SQL và thao tác con trỏ bằng mã Python, vì những thao tác này sẽ được ORM tự động hoàn thành. Sử dụng ORM của Django, chúng ta có thể trực tiếp biến bảng chủ đề và bảng giáo viên mà chúng ta vừa tạo thành các lớp mẫu trong Django.

## Sử dụng ORM để hoàn thành các thao tác CRUD của mô hình
Với ORM của framework Django, chúng ta có thể trực tiếp sử dụng phương pháp hướng đối tượng để thực hiện các thao tác CRUD (thêm, xóa, sửa đổi, truy vấn) trên dữ liệu. Chúng ta có thể nhập lệnh sau trong thiết bị đầu cuối PyCharm để vào môi trường tương tác của dự án Django, sau đó thử vận ​​hành mô hình.
    python manage.py shell
Mới
    from polls.models import Subject
xóa bỏ
    subject = Subject.objects.get(no=2)
    subject.delete()
thay mới
    subject = Subject.objects.get(no=1)
    subject.name = 'Python đầy đủ + trí tuệ nhân tạo'
    subject.save()
Hỏi thăm
1. Truy vấn tất cả các đối tượng.
    Subjects.objects.all()
2. Lọc dữ liệu.
3. Truy vấn một đối tượng duy nhất.
    Subject.objects.get(pk=1)
    Subject.objects.get(no=1)
    Subject.objects.filter(no=1).first()
    Subject.objects.filter(no=1).last()
4. Loại.
5. Cắt lát (truy vấn phân trang).
    Subject.objects.order_by('no')[:3]
6. đếm.
    Subject.objects.count()
7. Tìm kiếm nâng cao.

# Cookie và Session
Ta có thể tạo Captcha để thêm lớp xác minh
## Đọc và ghi cookie trong chức năng xem
Django được đóng gói HttpRequestvà HttpResponsecác đối tượng cung cấp các hoạt động để đọc và ghi cookie tương ứng.
Các thuộc tính và phương thức được gói gọn bởi HttpRequest:
1. COOKIESThuộc tính - Thuộc tính này chứa tất cả các cookie được yêu cầu HTTP mang theo.
2. get_signed_cookiePhương pháp - Nhận cookie đã ký và tạo BadSignaturengoại lệ nếu xác minh chữ ký không thành công.
Phương thức đóng gói HttpResponse:
1. set_cookiePhương thức - Phương thức này thiết lập một tập hợp các cặp khóa-giá trị cuối cùng sẽ được ghi vào trình duyệt.
2. set_signed_cookiePhương pháp - Tương tự như phương pháp trên, nhưng cookie sẽ được ký để tránh giả mạo. Vì nếu dữ liệu trong cookie bị giả mạo thì không thể tạo ra chữ ký hợp lệ nếu không biết key và saltBadSignature … Bằng cách này, khi máy chủ đọc cookie sẽ thấy dữ liệu không nhất quán với chữ ký và một ngoại lệ sẽ xảy ra. Cần lưu ý rằng key được đề cập ở đây là key chúng tôi đã chỉ định trong tệp cấu hình dự án Django SECRET_KEYvà salt là một chuỗi được đặt trong chương trình, bạn có thể đặt thành bất cứ thứ gì bạn muốn, miễn là chuỗi hợp lệ.
SessionMiddlewaresau khi kích hoạt, mỗi HttpRequestđối tượng sẽ bị ràng buộc vào một thuộc tính session, đây là một đối tượng giống như từ điển, ngoài việc lưu dữ liệu người dùng, nó còn cung cấp các phương thức để phát hiện xem trình duyệt có hỗ trợ cookie hay không, bao gồm:
1. set_test_cookiePhương pháp - Đặt cookie để thử nghiệm.
2. test_cookie_workedPhương pháp - Kiểm tra xem cookie thử nghiệm có hoạt động không.
3. delete_test_cookiePhương pháp - Xóa cookie được sử dụng để thử nghiệm.
4. set_expiryPhương pháp - Đặt thời gian hết hạn của phiên.
5. get_expire_age/ get_expire_datephương thức - Nhận thời gian hết hạn của phiên.
6. clear_expiredPhương pháp - Dọn dẹp các phiên hết hạn.
Dưới đây là đoạn mã kiểm tra xem trình duyệt có hỗ trợ cookie hay không trước khi thực hiện đăng nhập. Thông thường, các trình duyệt mặc định bật hỗ trợ cookie nhưng vì lý do nào đó, người dùng có thể đã tắt chức năng cookie của trình duyệt. Trong trường hợp này, chúng ta có thể cung cấp chức năng kiểm tra trong chức năng xem. Nếu người dùng Trình duyệt không hỗ trợ cookie và có thể đưa ra lời nhắc tương ứng.
def login(request):
    if request.method == 'POST':
        if request.session.test_cookie_worked():
            request.session.delete_test_cookie()
            # Add your code to perform login process here
        else:
            return HttpResponse("Please enable cookies and try again.")
    request.session.set_test_cookie()
    return render_to_response('login.html')

# Log và gỡ lỗi thanh công cụ
Có thể nhận thấy rằng cấu hình nhật ký ở trên formatterslà một trình định dạng nhật ký , đại diện cho cách định dạng nhật ký đầu ra. Các phần giữ chỗ định dạng đại diện cho:
1. %(name)s- tên của người ghi nhật ký
2. %(levelno)s- Mức ghi nhật ký ở dạng số
3. %(levelname)s- Tên văn bản của cấp độ ghi nhật ký
4. %(filename)s- Tên file của file nguồn thực hiện lệnh gọi ghi nhật ký
5. %(pathname)s- Tên đường dẫn của file nguồn thực hiện lệnh gọi ghi nhật ký
6. %(funcName)s- Tên hàm thực hiện lệnh gọi ghi nhật ký
7. %(module)s- Tên của mô-đun thực hiện lệnh gọi ghi nhật ký
8. %(lineno)s- Số dòng nơi thực hiện cuộc gọi ghi nhật ký
9. %(created)s- Việc ghi nhật ký thời gian đã được thực hiện
10. %(asctime)s- Ngày và giờ
11. %(msecs)s- phần mili giây
12. %(thread)d- ID chủ đề (số nguyên)
13. %(threadName)s- Tên chủ đề
14. %(process)d- ID tiến trình (số nguyên)
Các trình xử lý trong cấu hình nhật ký được sử dụng để chỉ định bộ xử lý nhật ký . Nói một cách đơn giản, nó chỉ định xem xuất nhật ký ra bảng điều khiển, tệp hay máy chủ trên mạng. Các bộ xử lý có sẵn bao gồm:
1. logging.StreamHandler(stream=None)- Có thể xuất thông tin ra bất kỳ đối tượng file nào tương tự sys.stdouthoặcsys.stderr
2. logging.FileHandler(filename, mode='a', encoding=None, delay=False)- Viết thông điệp tường trình vào tập tin
3. logging.handlers.DatagramHandler(host, port)- Sử dụng giao thức UDP để gửi thông tin nhật ký đến máy chủ mạng của máy chủ và cổng được chỉ định
4. logging.handlers.HTTPHandler(host, url)- Tải thông điệp tường trình lên máy chủ HTTP bằng phương thức GET hoặc POST của HTTP
5. logging.handlers.RotatingFileHandler(filename, mode='a', maxBytes=0, backupCount=0, encoding=None, delay=False)- Ghi thông điệp tường trình vào một tập tin, nếu kích thước tập tin vượt quá maxBytesgiá trị được chỉ định, một tập tin mới sẽ được tạo lại để ghi nhật ký.
6. logging.handlers.SocketHandler(host, port)- Sử dụng giao thức TCP để gửi thông tin nhật ký đến máy chủ mạng của máy chủ và cổng được chỉ định
7. logging.handlers.SMTPHandler(mailhost, fromaddr, toaddrs, subject, credentials=None, secure=None, timeout=1.0)- Xuất nhật ký tới địa chỉ email được chỉ định
8. logging.MemoryHandler(capacity, flushLevel=ERROR, target=None, flushOnClose=True)- Xuất nhật ký vào bộ đệm được chỉ định trong bộ nhớ
Mỗi bộ xử lý nhật ký ở trên chỉ định một levelthuộc tính có tên, đại diện cho cấp độ của nhật ký. Các cấp độ nhật ký khác nhau phản ánh mức độ nghiêm trọng của thông tin được ghi trong nhật ký. Sáu cấp độ nhật ký được xác định bằng Python, theo thứ tự từ thấp đến cao là: NOTSET, DEBUG, INFO, WARNING, ERROR, CRITICAL.
Trình ghi nhật ký được định cấu hình cuối cùng được sử dụng để xuất nhật ký thực sự. Khung công tác Django cung cấp một trình ghi nhật ký tích hợp như dưới đây:
1. django- tất cả các trình ghi nhật ký tin nhắn trong hệ thống phân cấp Django
2. django.request- Ghi nhật ký các thông báo liên quan đến việc xử lý yêu cầu. Phản hồi 5xx được coi là thông báo lỗi; phản hồi 4xx được coi là thông báo cảnh báo
3. django.server- Ghi nhật ký các thông báo liên quan đến các yêu cầu mà máy chủ gọi qua runserver nhận được. Phản hồi 5xx được coi là thông báo lỗi; phản hồi 4xx được ghi lại dưới dạng thông báo cảnh báo; mọi thứ khác được ghi lại dưới dạng THÔNG TIN
4. django.template- Thông điệp nhật ký liên quan đến kết xuất mẫu
5. django.db.backends- Có các thông điệp tường trình được tạo ra bằng cách tương tác với cơ sở dữ liệu, nếu bạn muốn hiển thị các câu lệnh SQL được thực thi bởi khung ORM, bạn có thể sử dụng trình ghi nhật ký này.
Cấp độ nhật ký được định cấu hình trong trình ghi nhật ký có thể không phải là cấp độ nhật ký cuối cùng, vì cấp độ nhật ký được định cấu hình trong bộ xử lý nhật ký phải được tham chiếu và cấp độ cao hơn trong hai cấp độ được sử dụng làm cấp độ nhật ký cuối cùng.

# Ứng dụng của middleware
Tệp cấu hình của dự án Django chứa cấu hình của phần mềm trung gian, mã như sau.
MIDDLEWARE = [
    'django.middleware.security.SecurityMiddleware',
    'django.contrib.sessions.middleware.SessionMiddleware',
    'django.middleware.common.CommonMiddleware',
    'django.middleware.csrf.CsrfViewMiddleware',
    'django.contrib.auth.middleware.AuthenticationMiddleware',
    'django.contrib.messages.middleware.MessageMiddleware',
    'django.middleware.clickjacking.XFrameOptionsMiddleware',
]
Hãy giải thích ngắn gọn chức năng của các phần mềm trung gian này:
1. CommonMiddleware- Middleware thiết lập cơ bản, có thể xử lý một số thông số cấu hình sau.
        DISALLOWED_USER_AGENTS - Tác nhân người dùng (trình duyệt) không được phép
        APPEND_SLASH - có nên nối thêm không/
        USE_ETAG - liên quan đến bộ đệm của trình duyệt
2. SecurityMiddleware- Middleware liên quan đến bảo mật, có thể xử lý các mục cấu hình liên quan đến bảo mật.
        SECURE_HSTS_SECONDS - Đã đến lúc buộc sử dụng HTTPS
        SECURE_HSTS_INCLUDE_SUBDOMAINS - Liệu HTTPS có bao gồm tên miền phụ hay không
        SECURE_CONTENT_TYPE_NOSNIFF - Có cho phép trình duyệt suy ra loại nội dung hay không
        SECURE_BROWSER_XSS_FILTER - Có bật bộ lọc tập lệnh chéo trang hay không
        SECURE_SSL_REDIRECT - có chuyển hướng đến kết nối HTTPS không
        SECURE_REDIRECT_EXEMPT - miễn trừ chuyển hướng sang HTTPS
3. SessionMiddleware- Phần mềm trung gian phiên.
4. CsrfViewMiddleware- Ngăn chặn giả mạo danh tính theo yêu cầu chéo bằng cách tạo mã thông báo.
5. XFrameOptionsMiddleware- Middleware để ngăn chặn các cuộc tấn công clickjacking bằng cách thiết lập các thông số tiêu đề yêu cầu.
Trong quá trình request, middleware trên sẽ được thực thi từ trên xuống dưới theo thứ tự viết, tiếp theo là phân tích URL và cuối cùng request sẽ đến với hàm view; trong quá trình phản hồi, middleware trên sẽ được thực thi trong Thứ tự viết Thực thi từ dưới lên trên, hoàn toàn ngược lại với thứ tự thực thi của middleware khi request.
Sau khi viết mã phần mềm trung gian, ta cần sửa đổi tệp cấu hình để kích hoạt phần mềm trung gian để nó hoạt động hiệu quả.
MIDDLEWARE = [
    'django.middleware.security.SecurityMiddleware',
    'django.contrib.sessions.middleware.SessionMiddleware',
    'django.middleware.common.CommonMiddleware',
    'django.middleware.csrf.CsrfViewMiddleware',
    'django.contrib.auth.middleware.AuthenticationMiddleware',
    'django.contrib.messages.middleware.MessageMiddleware',
    'django.middleware.clickjacking.XFrameOptionsMiddleware',
    'debug_toolbar.middleware.DebugToolbarMiddleware',
    'vote.middlewares.check_login_middleware',
]
Chú ý đến thứ tự các thành phần trong danh sách middleware ở trên, khi nhận được yêu cầu từ người dùng, middleware sẽ được thực thi theo thứ tự từ trên xuống dưới, sau khi các phần mềm trung gian này hoàn thành, yêu cầu cuối cùng sẽ đến được chức năng xem.

# Front-end vaf back-end
Có rất nhiều lợi ích khi sử dụng phát triển front-end và back-end riêng biệt
1. Nâng cao hiệu quả phát triển . Sau khi tách mặt trước và mặt sau, mã mặt trước và mặt sau có thể được tách rời, miễn là mặt trước và mặt sau giao tiếp và thống nhất về các giao diện và thông số giao diện cần thiết cho ứng dụng, sự phát triển song song có thể bắt đầu mà không cần đợi công việc phát triển của bên kia kết thúc. Trong trường hợp này, cả kỹ sư front-end và back-end đều có thể chỉ tập trung vào công việc phát triển của riêng họ, giúp xây dựng một nhóm tốt hơn. Ngoài ra, trong mô hình phát triển nơi mặt trước và mặt sau được tách biệt, ngay cả khi yêu cầu thay đổi, miễn là giao diện và định dạng dữ liệu không thay đổi, các nhà phát triển back-end không cần sửa đổi mã, miễn là những thay đổi ở mặt trước.
2. Cải thiện khả năng bảo trì mã . Sau khi tách biệt front-end và back-end, mã ứng dụng không còn là sự trộn lẫn giữa front-end và front-end nữa mà chỉ có các cuộc gọi phụ thuộc trong thời gian chạy, bằng cách này, công việc duy trì mã sẽ trở nên dễ dàng và thú vị hơn nhiều và nó sẽ không còn ảnh hưởng đến toàn bộ cơ thể nữa. Khi mã của bạn trở nên ngắn gọn và rõ ràng, khả năng đọc và bảo trì của mã sẽ được cải thiện về chất lượng.
3. Hỗ trợ kiến ​​trúc đa thiết bị đầu cuối và dựa trên dịch vụ . Sau khi tách biệt mặt trước và mặt sau, cùng một bộ giao diện dữ liệu có thể cung cấp dịch vụ cho các thiết bị đầu cuối khác nhau, điều này có lợi hơn cho việc tạo các ứng dụng nhiều thiết bị đầu cuối; Ngoài ra, vì các giao diện được cung cấp bởi mặt sau có thể được gọi thông qua HTTP( S), nó có lợi cho việc tạo ra kiến ​​trúc dịch vụ (bao gồm cả vi dịch vụ).
Trong chế độ phát triển mà mặt trước và mặt sau được tách biệt, mặt sau cần cung cấp giao diện dữ liệu cho mặt trước, các giao diện này thường trả về dữ liệu ở định dạng JSON. Trong dự án Django, trước tiên chúng ta có thể xử lý đối tượng thành một từ điển, sau đó sử dụng tính năng đóng gói Django để JsonResponsetrả về dữ liệu ở định dạng JSON cho trình duyệt.
def show_subjects(request):
    queryset = Subject.objects.all()
    subjects = []
    for subject in queryset:
        subjects.append({
            'no': subject.no,
            'name': subject.name,
            'intro': subject.intro,
            'isHot': subject.is_hot
        })
    return JsonResponse(subjects, safe=False)

# Kiến trúc RESTful và DRF
iến phần mềm, nền tảng, cơ sở hạ tầng thành dịch vụ là điều mà nhiều công ty CNTT đã và đang làm, đây là điều bạn thường nghe về SaS (Software as a Service) và PaS (Platform as a service) và IasS (infrastructure as a service) ). Có nhiều cách để triển khai kiến ​​trúc hướng dịch vụ (SOA), bao gồm RPC (gọi thủ tục từ xa), Dịch vụ web, REST, v.v. Ở cấp độ kỹ thuật, SOA là một kiến ​​trúc phần mềm trừu tượng, liên kết lỏng lẻo, chi tiết thô; Mặt khác, các khái niệm cốt lõi của SOA là " tái sử dụng " và " khả năng tương tác ", tích hợp các tài nguyên hệ thống vào các dịch vụ tiêu chuẩn, có thể hoạt động để các tài nguyên này có thể được kết hợp lại và áp dụng. Trong số nhiều giải pháp triển khai SOA, REST được coi là kiến ​​trúc phù hợp nhất cho các ứng dụng Internet, các kiến ​​trúc tuân thủ các đặc tả REST thường được gọi là kiến ​​trúc RESTful.
## Sự tách biệt giữa front-end và back-end
Theo dõi người dùng dựa trên mã thông báo là tạo danh tính cho người dùng sau khi người dùng đăng nhập thành công và lưu nó vào bộ nhớ cục bộ của trình duyệt (localStorage, sessionStorage, cookie, v.v.). Trong trường hợp này, máy chủ không cần lưu trạng thái người dùng nên có thể dễ dàng thực hiện. Quy trình theo dõi người dùng dựa trên mã thông báo cụ thể như sau:
1. Khi người dùng đăng nhập, nếu đăng nhập thành công, mã thông báo sẽ được tạo cho người dùng theo một cách nào đó. Mã thông báo thường chứa thông tin nhận dạng người dùng, thời gian hết hạn và các thông tin khác và cần được mã hóa và tạo dấu vân tay (để tránh giả mạo hoặc giả mạo the token) , máy chủ sẽ trả lại mã thông báo cho giao diện người dùng;
2. Giao diện người dùng lấy mã thông báo được máy chủ trả về và lưu nó vào bộ nhớ cục bộ của trình duyệt (nó có thể được lưu trong localStoragehoặc sessionStorage. Đối với các dự án giao diện người dùng sử dụng Vue.js, việc quản lý trạng thái cũng có thể được thực hiện thông qua Vuex);
3. Đối với các dự án sử dụng định tuyến giao diện người dùng, mỗi khi tuyến giao diện người dùng nhảy, trước tiên bạn có thể xác định xem localStroagecó mã thông báo hay không và nếu không, hãy chuyển đến trang đăng nhập;
4. Mỗi lần yêu cầu giao diện dữ liệu phụ trợ, mã thông báo sẽ được mang trong tiêu đề yêu cầu HTTP, giao diện phụ trợ xác định xem tiêu đề yêu cầu có mã thông báo hay không, nếu không có mã thông báo hoặc mã thông báo không hợp lệ hoặc hết hạn, máy chủ sẽ trả về thống nhất 401;
5. Nếu giao diện người dùng nhận được mã trạng thái phản hồi HTTP 401, nó sẽ chuyển hướng đến trang đăng nhập.
## Ưu điểm và nhược điểm của JWT
Ưu điểm của việc sử dụng JWT là rõ ràng, bao gồm:
1. Dễ dàng mở rộng quy mô theo chiều ngang hơn vì mã thông báo được lưu trữ trong trình duyệt và máy chủ không cần thực hiện quản lý trạng thái.
2. localStorageViệc ngăn chặn các cuộc tấn công CSRF sẽ dễ dàng hơn vì mã thông báo được thêm vào hoặc trong tiêu đề yêu cầu sessionStoragephải được hoàn thành bằng mã JavaScript thay vì tự động được thêm vào tiêu đề yêu cầu.
3. Nó có thể ngăn chặn sự giả mạo và giả mạo vì JWT có chữ ký. Các mã thông báo giả mạo và giả mạo không thể vượt qua quá trình xác minh chữ ký và sẽ bị coi là mã thông báo không hợp lệ.
Tất nhiên công nghệ nào cũng không thể chỉ có ưu điểm mà không có nhược điểm, JWT cũng có rất nhiều nhược điểm mà mọi người cần lưu ý khi sử dụng, bao gồm:
1. Bạn có thể phải đối mặt với các cuộc tấn công XSS (tấn công tập lệnh chéo trang) và lấy mã thông báo của người dùng bằng cách chèn các tập lệnh độc hại để thực thi mã JavaScript.
2. Trước khi mã thông báo hết hạn, mã thông báo đã phát hành không thể bị vô hiệu. Để giải quyết vấn đề này, cần có thêm các lớp ở giữa và mã để hỗ trợ.
3. JWT là mã thông báo nhận dạng của người dùng và một khi bị rò rỉ, bất kỳ ai cũng có thể có được tất cả các quyền của người dùng đó. Để giảm nguy cơ bị đánh cắp mã thông báo, thời hạn hiệu lực của JWT phải được đặt tương đối ngắn. Đối với một số quyền quan trọng hơn, người dùng phải được xác thực lại thông qua các phương pháp khác, chẳng hạn như mã xác minh SMS, v.v.

# Sử dụng bộ nhớ đệm
## Dự án Django kết nối với Redis
Nếu cần truy cập Redis trong dự án Django, bạn có thể sử dụng thư viện của bên thứ 3. django-redisThư viện của bên thứ ba này phụ thuộc vào redisthư viện của bên thứ ba có tên , gói gọn các hoạt động khác nhau trên Redis.
## Cung cấp dịch vụ bộ nhớ đệm cho lượt xem
### Bộ nhớ đệm khai báo
Cái gọi là bộ nhớ đệm khai báo đề cập đến việc thêm các hàm bộ nhớ đệm vào mã gốc thông qua trình trang trí (tác nhân) trong Python mà không sửa đổi mã gốc.
### Bộ nhớ đệm có lập trình
Cái gọi là bộ đệm theo chương trình đề cập đến việc sử dụng dịch vụ bộ đệm thông qua mã do chính bạn viết, mặc dù số lượng mã trong phương thức này lớn hơn một chút nhưng so với bộ đệm khai báo, nó linh hoạt hơn trong hoạt động và sử dụng bộ đệm và được sử dụng trong phát triển thực tế. nhận được nhiều hơn nữa. Đoạn mã sau loại bỏ cache_pagetrình trang trí được sử dụng trước đó và trực tiếp lấy kết nối Redis thông qua chức năng django-redisđược cung cấp get_redis_connectionđể vận hành Redis.
## Các vấn đề liên quan đến bộ nhớ đệm
### Cập nhật dữ liệu được lưu trong bộ nhớ đệm
Khi sử dụng cache, một vấn đề cần làm rõ là làm thế nào để cập nhật dữ liệu trong cache khi dữ liệu thay đổi. Thông thường có một số cách để cập nhật bộ đệm, cụ thể là:
1. Mẫu bộ nhớ đệm bên cạnh
2. Đọc/Ghi Qua Mẫu
3. Viết đằng sau mẫu bộ nhớ đệm
### thâm nhập bộ nhớ đệm
Cache là lớp trung gian được thêm vào để giảm bớt áp lực cho cơ sở dữ liệu, nếu những kẻ truy cập độc hại thường xuyên truy cập vào dữ liệu không có trong bộ đệm thì bộ nhớ đệm sẽ mất đi ý nghĩa, ngay lập tức, áp lực của mọi yêu cầu sẽ đổ dồn lên cơ sở dữ liệu. Điều này sẽ dẫn đến cơ sở dữ liệu phải chịu áp lực rất lớn và thậm chí gây ra các kết nối bất thường, tương tự như một cuộc tấn công từ chối dịch vụ phân tán (DDoS). Một cách để giải quyết vấn đề thâm nhập bộ đệm là đồng ý rằng nếu truy vấn trả về giá trị null thì giá trị null cũng sẽ được lưu vào bộ đệm. Tuy nhiên, cần đặt khoảng thời gian chờ ngắn hơn cho bộ đệm của giá trị null này. value là sự lãng phí không gian bộ nhớ đệm. Một cách khác để giải quyết vấn đề thâm nhập bộ đệm là sử dụng bộ lọc Bloom, bạn có thể tự tìm hiểu phương pháp cụ thể.
### Phân tích bộ nhớ đệm
Trong một dự án thực tế, có thể có một cached key hết hạn vào một thời điểm nhất định nhưng tại thời điểm đó có một số lượng lớn các yêu cầu đồng thời về key, các yêu cầu này không tìm thấy dữ liệu tương ứng với key từ cache , do đó Dữ liệu sẽ được lấy trực tiếp từ cơ sở dữ liệu và ghi trở lại bộ đệm. Lúc này, các yêu cầu đồng thời lớn có thể ngay lập tức khiến cơ sở dữ liệu bị quá tải. Hiện tượng này gọi là lỗi bộ nhớ đệm. Một cách phổ biến hơn để giải quyết sự cố bộ đệm là sử dụng khóa mutex. Nói một cách đơn giản, khi bộ đệm bị lỗi, thay vì truy cập ngay vào cơ sở dữ liệu để tải dữ liệu, khóa mutex sẽ được đặt trước (ví dụ: setnx trong Redis) và chỉ khóa setnx được đặt. Chỉ yêu cầu vận hành thành công mutex mới có thể thực hiện truy vấn để tải dữ liệu từ cơ sở dữ liệu và ghi dữ liệu vào bộ đệm. Các yêu cầu khác không đặt được mutex trước tiên có thể thực hiện một chế độ ngủ ngắn, sau đó thử để lấy lại dữ liệu từ bộ đệm. Nếu bộ đệm Nếu chưa có dữ liệu, hãy lặp lại thao tác thiết lập khóa mutex vừa rồi. Mã tham chiếu gần đúng như sau.

data = redis_cli.get(key)
while not data:
    if redis_cli.setnx('mutex', 'x'):
        redis.expire('mutex', timeout)
        data = db.query(...)
        redis.set(key, data)
        redis.delete('mutex')
    else:
        time.sleep(0.1)
        data = redis_cli.get(key)
### tuyết lở bộ nhớ đệm
Cache Avalanche có nghĩa là thời gian hết hạn giống nhau được sử dụng khi đưa dữ liệu vào bộ đệm, khiến bộ đệm hết hạn cùng lúc tại một thời điểm nhất định và tất cả các yêu cầu đều được chuyển tiếp đến cơ sở dữ liệu, khiến cơ sở dữ liệu bị sập do quá tải tức thời. áp lực. Phương pháp giải quyết vấn đề tuyết lở bộ đệm cũng tương đối đơn giản, bạn có thể thêm thời gian ngẫu nhiên vào thời gian hết hạn bộ đệm đã thiết lập, điều này có thể tránh được ở một mức độ nhất định lỗi chung của các khóa khác nhau cùng một lúc. Một cách khác là sử dụng cache nhiều cấp, thời gian hết hạn của mỗi cấp cache là khác nhau, bằng cách này, ngay cả khi một cấp cache nhất định bị lỗi chung thì các cấp cache khác vẫn có thể cung cấp dữ liệu để tránh mọi yêu cầu rơi vào cơ sở dữ liệu. 


# Truy cập vào platform của bên thứ 3
Về cơ bản có hai cách để truy cập nền tảng của bên thứ ba trong các dự án: truy cập API và truy cập SDK.
1. Quyền truy cập API đề cập đến việc hoàn thành các hoạt động hoặc thu thập dữ liệu bằng cách truy cập các URL do bên thứ ba cung cấp. Có rất nhiều nền tảng như vậy ở Trung Quốc cung cấp một số lượng lớn các dịch vụ được sử dụng phổ biến.
2. Quyền truy cập SDK đề cập đến phương pháp sử dụng các dịch vụ do nền tảng bên thứ ba cung cấp bằng cách cài đặt thư viện của bên thứ ba cũng như sử dụng các lớp và hàm được gói gọn bởi thư viện bên thứ ba. 
## Truy cập cổng SMS
ó nhiều nơi có thể sử dụng dịch vụ SMS trong một dự án Web, chẳng hạn như: đăng nhập mã xác minh điện thoại di động, nhắc nhở tin nhắn quan trọng, SMS tiếp thị sản phẩm, v.v. Để nhận ra chức năng gửi tin nhắn văn bản, bạn có thể đạt được nó bằng cách truy cập vào cổng SMS. Các cổng SMS trong nước nổi tiếng hơn bao gồm: Yunpian SMS, NetEase Yunxin, Screwcap, SendCloud, v.v.
1. Đăng ký một tài khoản và người dùng mới có thể dùng thử miễn phí.
2. Đăng nhập vào nền quản lý và nhập phần SMS.
3. Nhấp vào "Gửi kích hoạt" để tìm Khóa API của riêng bạn (mã định danh nhận dạng).
4. Nhấp vào "Quản lý chữ ký" để thêm chữ ký vào tin nhắn văn bản. Tất cả tin nhắn văn bản phải có chữ ký. Đối với tin nhắn văn bản dùng thử miễn phí, chữ ký "[Iron Shell Test]" phải được thêm vào tin nhắn văn bản, nếu không tin nhắn văn bản sẽ không thể gửi được
5. Bấm vào "IP Whitelist" để điền địa chỉ server chạy dự án Django (địa chỉ IP public, khi chạy cục bộ bạn có thể mở trang web xxx để xem địa chỉ IP public của chính mình) vào whitelist, nếu không thì không gửi được tin nhắn .
6. Nếu không còn tin nhắn nào, bạn có thể vào trang "Nạp tiền" và chọn "Dịch vụ SMS" để nạp tiền
## try cập dịch vụ lưu trữ đám mây

# Nhiệm vụ không đồng bộ và nhiệm vụ theo lịch trình
Trong ứng dụng web, nếu một yêu cầu thực hiện một thao tác tốn thời gian hoặc không thể xác định được thời gian thực hiện của yêu cầu và người dùng chỉ cần biết rằng máy chủ đã nhận được yêu cầu của mình và không cần lấy kết quả thực hiện của yêu cầu ngay lập tức, như thế này Chúng ta nên xử lý thao tác một cách không đồng bộ. Nếu sử dụng bộ đệm là điều quan trọng đầu tiên để tối ưu hóa hiệu suất trang web , thì việc không đồng bộ hóa các tác vụ tốn thời gian hoặc thời gian thực hiện không chắc chắn là điều quan trọng thứ hai để tối ưu hóa hiệu suất trang web . Nói một cách đơn giản, đừng làm bất cứ điều gì có thể bị trì hoãn ngay lập tức .
Việc xử lý không đồng bộ trong các dự án Python có thể được thực hiện bằng cách sử dụng đa luồng hoặc sử dụng thư viện Celery của bên thứ ba.

# Phát triển giao diện dữ liệu mạng với FastAPI
FastAPI là một khung web hiện đại, hiệu suất cao để xây dựng các API (giao diện dữ liệu mạng). Nó dựa trên Python 3.6+ và sử dụng các gợi ý kiểu trong Python để kiểm tra kiểu. Nó rất phù hợp với nhu cầu phát triển kỹ thuật và có một danh tiếng rất tốt trong ngành.
## Bắt đầu với FastAPI
1. Cài đặt các thư viện phụ thuộc và máy chủ ASGI (máy chủ Python hỗ trợ I/O không đồng bộ).
    pip install fastapi
    pip install uvicorn
2. Viết mã main.py.
    from fastapi import FastAPI

    app = FastAPI()


    @app.get('/')
    def say_hello():
        return {'code': 200, 'message': 'hello, world!'}
3. Chạy dịch vụ.
    uvicorn main:app --reload
4. Dịch vụ truy cập.
## Truy cập cơ sở dữ liệu quan hệ
Chúng ta có thể sử dụng thư viện của bên thứ ba SQLAlchemy để có quyền truy cập vào cơ sở dữ liệu quan hệ. SQLAlchemy là một khung ORM (Bản đồ quan hệ đối tượng), khung ORM có thể giải quyết vấn đề không khớp giữa mô hình hướng đối tượng của chương trình Python và mô hình quan hệ của cơ sở dữ liệu quan hệ, cho phép chúng ta thực hiện các thao tác CRUD trên dữ liệu theo hướng đối tượng thái độ.
## Triển khai ảo hóa (Docker)